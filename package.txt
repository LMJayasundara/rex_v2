{
  "name": "braid-app",
  "version": "1.0.1",
  "description": "BRAID CUT & MARK MACHINE",
  "main": "index.js",
  "scripts": {
    "start": "nodemon --watch index.js --exec electron .",
    "dist": "electron-builder"
  },
  "repository": "https://github.com/LMJayasundara/RexAppUpdater",
  "publish": {
    "provider": "github",
    "releaseType": "release"
  },
  "build": {
    "appId": "com.braidapp.autoupdater",
    "productName": "Braid App",
    "win": {
      "target": "nsis"
    },
    "directories": {
      "output": "dist"
    },
    "extraResources": [
      "database"
    ],
    "asarUnpack": [
      "dist/database/main.db"
    ]
  },
  "keywords": [],
  "author": "JMJayasundara",
  "license": "ISC",
  "devDependencies": {
    "electron": "^19.1.6",
    "electron-builder": "^23.6.0",
    "nodemon": "^2.0.20"
  },
  "dependencies": {
    "electron-store": "^8.1.0",
    "electron-updater": "^5.3.0",
    "serialport": "^10.5.0",
    "sqlite3": "^5.1.2"
  }
}
////////////////////////////////////////

const val = require('./reg');
const map = (val.map);
const dis = (val.dis);
const rotVal = [150, 150, 150];

function clearReg() {
    return new Promise((resolve, reject) => {
      const numRegisters = 100;
      const values = new Array(numRegisters).fill(0);
      var start = 41387;
      for (let i = 0; i < 10; i++) {
        client.writeMultipleRegisters(start, values);
        start = start + 100;
      }
      resolve();
    });
};

async function writeCoil(mapReg, mapVal, disReg, disVal) {
    return new Promise((resolve, reject) => {
        client.writeSingleRegister(mapReg, mapVal).then((response) => {
            console.log(mapReg, mapVal);
            resolve();
        }).catch((error) => {
            dialog.showErrorBox(`MapReg ${mapReg} Error`, error.message);
        });
    }).then(()=>{
        client.writeSingleRegister(disReg, disVal).then((response) => {
            console.log(disReg, disVal);
        }).catch((error) => {
            dialog.showErrorBox(`DisReg ${disReg} Error`, error.message);
        });
    });
};


ipcMain.handle('exeStart', (event, obj) => {
    readGigTable(obj).then((data) => {
        // console.log(data);
        return data;
    })
    // .then(async(data)=>{
    //     await clearReg();
    //     return data;
    // })
    .then((data) => {
        data.forEach(async(element, i) => {
            if (element.clr == 'Green') {
                // console.log(i, map[i][0], rotVal[0], dis[i][0], element.gap);
                await writeCoil(map[i][0], rotVal[0], dis[i][0], element.gap);
            }
            else if (element.clr == 'Black') {
                // console.log(i, map[i][1], rotVal[1], dis[i][0], element.gap);
                await writeCoil(map[i][1], rotVal[1], dis[i][0], element.gap);
            }
            else if (element.clr == 'Blue') {
                // console.log(i, map[i][2], rotVal[2], dis[i][0], element.gap);
                await writeCoil(map[i][2], rotVal[2], dis[i][0], element.gap);
            }
            else {
                console.log('error');
            }
        });
    });
});