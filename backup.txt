/////////////////////////////////// Execute Operations ///////////////////////////////////

// function clearReg() {
//     return new Promise((resolve, reject) => {
//         const numRegisters = 100;
//         const values = new Array(numRegisters).fill(0);
//         var start = 41387;
//         for (let i = 0; i < 10; i++) {
//             client.writeMultipleRegisters(start, values)
//                 .then(() => {
//                     if (i === 9) {
//                         resolve();
//                     }
//                 })
//                 .catch((error) => {
//                     dialog.showErrorBox(`Registers Cleared Error`, error.message);
//                 });
//             start = start + 100;
//         }
//     });
// };

// async function writeReg(mapReg, mapVal, disReg, disVal) {
//     return new Promise((resolve, reject) => {
//         client.writeSingleRegister(mapReg, mapVal).then((response) => {
//             resolve();
//         }).catch((error) => {
//             dialog.showErrorBox(`Error in ${mapReg}`, error.message);
//         });
//     }).then(() => {
//         client.writeSingleRegister(disReg, disVal).then((response) => {
//         }).catch((error) => {
//             dialog.showErrorBox(`Error in ${disReg}`, error.message);
//         });
//     }).catch((error) => {
//         dialog.showErrorBox(`Registers Write Error`, error.message);
//     });
// };

// // Start Execution
// ipcMain.handle('exeStart', (event, obj) => {
//     clearReg()
//         .then(() => {
//             readGigTable(obj)
//                 .then((data) => {
//                     return data;
//                 })
//                 .then(async(data) => {
//                     data.forEach(async (element, i) => {
//                         if (element.clr == 'Green') {
//                             console.log(i, map[i][0], rotVal[0], dis[i][0], element.gap);
//                             await writeReg(map[i][0], rotVal[0], dis[i][0], element.gap);
//                         }
//                         else if (element.clr == 'Black') {
//                             console.log(i, map[i][1], rotVal[1], dis[i][0], element.gap);
//                             await writeReg(map[i][1], rotVal[1], dis[i][0], element.gap);
//                         }
//                         else if (element.clr == 'Blue') {
//                             console.log(i, map[i][2], rotVal[2], dis[i][0], element.gap);
//                             await writeReg(map[i][2], rotVal[2], dis[i][0], element.gap);
//                         }
//                     });

//                     store.set('exeStatus', true);
//                     await master.writeMultipleCoils(2000, [true, false], 2)
//                 });
//         }).catch((error) => {
//             dialog.showErrorBox(`Registers Cleared Error`, error.message);
//         });
// });

/////////////////////////////////// Manual Operations ///////////////////////////////////
// // Main Roll
// ipcMain.handle('upMainRoll', (event, obj) => {
//     console.log('upMainRoll');
//     client.writeSingleCoil(22, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('MainRoll Up Error', error.message);
//     });
// });

// ipcMain.handle('downMainRoll', (event, obj) => {
//     console.log('downMainRoll');
//     client.writeSingleCoil(22, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('MainRoll Down Error', error.message);
//     });
// });

// // Guid Board
// ipcMain.handle('pullGuidBoard', (event, obj) => {
//     console.log('pullGuidBoard');
//     client.writeSingleCoil(24, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('GuidBoard Pull Error', error.message);
//     });
// });

// ipcMain.handle('resetGuidBoard', (event, obj) => {
//     console.log('resetGuidBoard');
//     client.writeSingleCoil(24, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('GuidBoard Reset Error', error.message);
//     });
// });

// // Cutter
// ipcMain.handle('btnBladeon', (event, obj) => {
//     console.log('btnBladeon');
//     client.writeSingleCoil(30, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Blade On Error', error.message);
//     });
// });

// ipcMain.handle('btnBladeoff', (event, obj) => {
//     console.log('btnBladeoff');
//     client.writeSingleCoil(30, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Blade Off Error', error.message);
//     });
// });

// // Braid In
// ipcMain.handle('dragBraidIn', (event, obj) => {
//     console.log('dragBraidIn');
//     client.writeSingleCoil(32, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Braid In Error', error.message);
//     });
// });

// ipcMain.handle('resetDragBraidIn', (event, obj) => {
//     console.log('resetDragBraidIn');
//     client.writeSingleCoil(32, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Braid In Reset Error', error.message);
//     });
// });

// // Home
// ipcMain.handle('btnactHomeManual', (event, obj) => {
//     console.log('btnactHomeManual');
//     actHome();
// });

// // Braid Out
// ipcMain.handle('getBraidOut', (event, obj) => {
//     console.log('getBraidOut');
//     client.writeSingleCoil(40, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Braid Out Error', error.message);
//     });
// });

// ipcMain.handle('resetGetBraidOut', (event, obj) => {
//     client.writeSingleCoil(40, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Braid Out Reset Error', error.message);
//     });
// });

// // Dragging Roll
// ipcMain.handle('releaseDraggingRoll', (event, obj) => {
//     console.log('releaseDraggingRoll');
//     client.writeSingleCoil(28, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Release Dragging Roll Error', error.message);
//     });
// });

// ipcMain.handle('setDraggingRoll', (event, obj) => {
//     console.log('setDraggingRoll');
//     client.writeSingleCoil(28, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Set Dragging Roll Error', error.message);
//     });
// });

// // Set Heat Seal
// ipcMain.handle('setHeat', (event, obj) => {
//     console.log('setHeat');
//     client.writeSingleCoil(10, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Set Heat Error', error.message);
//     });
// });

// ipcMain.handle('resetsetHeat', (event, obj) => {
//     console.log('resetsetHeat');
//     client.writeSingleCoil(10, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Reset Heat Error', error.message);
//     });
// });

// // Ink Roll
// ipcMain.handle('runInkRoll', (event, obj) => {
//     console.log('runInkRoll');
//     client.writeSingleCoil(33, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Run Ink Roll Error', error.message);
//     });
// });

// ipcMain.handle('stopInkRoll', (event, obj) => {
//     console.log('stopInkRoll');
//     client.writeSingleCoil(33, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Stop Ink Roll Error', error.message);
//     });
// });

// // Cutter Fwd
// ipcMain.handle('cutterFwd', (event, obj) => {
//     console.log('cutterFwd');
//     client.writeSingleCoil(12, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Cutter Forward Error', error.message);
//     });
// });

// ipcMain.handle('stpCutterFwd', (event, obj) => {
//     console.log('stpCutterFwd');
//     client.writeSingleCoil(12, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Cutter Forward Stop Error', error.message);
//     });
// });

// // Cutter Rvs
// ipcMain.handle('cutterRvs', (event, obj) => {
//     console.log('cutterRvs');
//     client.writeSingleCoil(34, true).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Cutter Reverse Error', error.message);
//     });
// });

// ipcMain.handle('stpCutterRvs', (event, obj) => {
//     console.log('stpCutterRvs');
//     client.writeSingleCoil(34, false).then((response) => {
//     }).catch((error) => {
//         dialog.showErrorBox('Cutter Reverse Stop Error', error.message);
//     });
// });

//////////////////////////////////////////////////////////////////////////////////////

async function handleAction(event, obj, action) {
  try {
    switch (action) {
      case 'upMainRoll':
        await client.writeSingleCoil(22, true);
        break;
      case 'downMainRoll':
        await client.writeSingleCoil(22, false);
        break;

      case 'pullGuidBoard':
        await client.writeSingleCoil(24, true);
        break;
      case 'resetGuidBoard':
        await client.writeSingleCoil(24, false);
        break;
      
    }
  } catch (error) {
    dialog.showErrorBox(`${action} Error`, error.message);
  }
}

ipcMain.handle('upMainRoll', handleAction.bind(null, 'upMainRoll'));
ipcMain.handle('downMainRoll', handleAction.bind(null, 'downMainRoll'));
ipcMain.handle('pullGuidBoard', handleAction.bind(null, 'pullGuidBoard'));
ipcMain.handle('resetGuidBoard', handleAction.bind(null, 'resetGuidBoard'));
ipcMain.handle('btnBladeon', () => handleAction('btnBladeon'));
ipcMain.handle('btnBladeoff', () => handleAction('btnBladeoff'));
ipcMain.handle('dragBraidIn', () => handleAction('dragBraidIn'));
ipcMain.handle('resetDragBraidIn', () => handleAction('resetDragBraidIn'));
ipcMain.handle('btnactHomeManual', () => handleAction('btnactHomeManual'));
ipcMain.handle('getBraidOut', () => handleAction('getBraidOut'));
ipcMain.handle('resetGetBraidOut', () => handleAction('resetGetBraidOut'));
ipcMain.handle('releaseDraggingRoll', () => handleAction('releaseDraggingRoll'));
ipcMain.handle('setDraggingRoll', () => handleAction('setDraggingRoll'));
ipcMain.handle('setHeat', () => handleAction('setHeat'));
ipcMain.handle('resetsetHeat', () => handleAction('resetsetHeat'));
ipcMain.handle('runInkRoll', () => handleAction('runInkRoll'));
ipcMain.handle('stopInkRoll', () => handleAction('stopInkRoll'));
ipcMain.handle('cutterFwd', () => handleAction('cutterFwd'));
ipcMain.handle('stpCutterFwd', () => handleAction('stpCutterFwd'));
ipcMain.handle('cutterRvs', () => handleAction('cutterRvs'));
ipcMain.handle('stpCutterRvs', () => handleAction('stpCutterRvs'));

////////////////////////////////////////////////////////////////////////////////////

// // Start Execution
// ipcMain.handle('exeStart', async (_, obj) => {
//     if(store.get('exeStatus') == 'start') {
//         const options = {
//             type: 'info',
//             buttons: ['OK'],
//             defaultId: 0,
//             cancelId: 0,
//             title: 'Execution Mode!',
//             message: 'Already running a execution!',
//             detail: 'Wait untill completion or stop the current execution!',
//             alwaysOnTop: true
//         };
//         dialog.showMessageBox(mainWindow, options);
//     }
//     else {
//         const options = {
//             type: 'warning',
//             buttons: ['Yes', 'No'],
//             defaultId: 1,
//             cancelId: 1,
//             title: 'Warning!',
//             message: `Do you want to start the execution?`,
//             detail: `It will start the execution!`
//         };
//         const returnValue = await dialog.showMessageBox(mainWindow, options);
//         if (returnValue.response === 0) {
//             if(obj != null){
//                 await getDetFile(obj).then((data)=>{
//                     store.set('exeObj', data);
//                 });
//                 await exeStart(obj, store.get('exeObj')[0].turn);
//                 await turnUpdate();
//             }
//             else{
//                 const options = {
//                     type: 'error',
//                     buttons: ['OK'],
//                     defaultId: 0,
//                     cancelId: 0,
//                     title: 'Error!',
//                     message: 'Not Selected!',
//                     detail: 'Slect table to execute the programe!',
//                     alwaysOnTop: true,
//                     noLink: true
//                 };
//                 const returnValue = await dialog.showMessageBox(mainWindow, options);
//             }
//         }else {
//             return
//         }
//     }
// });

// // Pre Print Execution
// ipcMain.handle('exePre', async(_, obj) => {
//     if(store.get('exeStatus') == 'start') {
//         const options = {
//             type: 'info',
//             buttons: ['OK'],
//             defaultId: 0,
//             cancelId: 0,
//             title: 'Execution Mode!',
//             message: 'Already running a execution!',
//             detail: 'Wait untill completion or stop the current execution!',
//             alwaysOnTop: true
//         };
//         dialog.showMessageBox(mainWindow, options);
//     }
//     else {
//         const options = {
//             type: 'warning',
//             buttons: ['Yes', 'No'],
//             defaultId: 1,
//             cancelId: 1,
//             title: 'Warning!',
//             message: `Do you want to start the execution?`,
//             detail: `It will start the execution!`
//         };
//         const returnValue = await dialog.showMessageBox(mainWindow, options);
//         if (returnValue.response === 0) {
//             if(obj != null){
//                 await getDetFile(obj).then((data)=>{
//                     store.set('exeObj', data);
//                 });
//                 await exeStart(obj, 1);
//                 await turnUpdate();
//             }
//             else{
//                 const options = {
//                     type: 'error',
//                     buttons: ['OK'],
//                     defaultId: 0,
//                     cancelId: 0,
//                     title: 'Error!',
//                     message: 'Not Selected!',
//                     detail: 'Slect table to execute the programe!',
//                     alwaysOnTop: true,
//                     noLink: true
//                 };
//                 const returnValue = await dialog.showMessageBox(mainWindow, options);
//             }
//         }else {
//             return
//         }
//     }
// });
